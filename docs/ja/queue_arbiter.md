Queue Arbiter Module
--------------------

### 概要

キュー(ファーストインファーストアウト)方式の調停回路です.

リクエストを到着順に許可することを特徴とします.

キュー方式が他の一般的な固定優先順位方式やラウンドロビン方式に比べて有利な点は次の二つ.

  * 必ずリクエストはいつかは許可されることが保証されています.
    固定優先順位方式の場合、場合によっては永久にリクエストが許可されることがないことが起り得ますが、
    キュー方式はそれがありません.
  * リクエストされた順番が変わることがありません.
    用途によっては順番が変わることで誤動作する場合がありますが、
    キュー方式ではそれに対応できます.

キュー方式が他の一般的な固定優先順位方式やラウンドロビン方式に比べて不利な点は次の二つ.

  * リクエストが到着した順番を記録しているため、回路規模は他の方式に比べて大きい傾向があります.
    特にリクエストの数が増えると二乗のオーダーで回路規模が大きくなります.
  * １クロックで多数の処理を行わなければならないので動作周波数が他の方式に比べて遅い傾向があります.
    特にリクエストの数が増えると比例して遅延時間が増大します.


内部でリクエストを保持しておくやり方の違いでアーキテクチャは二つ用意してあります.

 * リクエストを記録しておくのにワンホットを使っているもの(queue_arbiter_one_hot_arch.vhd).
 * リクエストを記録しておくのに単なる整数を使っているもの(queue_arbiter_integer_arch.vhd).

どちらがよいか迷ったのですが、よく分からないので両方アップしました。


実は昔、バスやメモリアクセスの調停がらみでよくトラブルを起しました.
例えば、タイミングによってはある回路からのリクエストが一切処理されずに見掛け上システムがフリーズしてしまうとか、メモリアクセス時にアクセス順が入れ替わってしまって誤動作するなどなど。

その時痛感したのが、調停を甘く見てはいけないということです。これを間違えると、とても分かりにくく且つ致命的なトラブルを起します。

これに懲りて、調停回路には固定優先順位方式やラウンドロビン方式を使うことは止めました。
多少回路規模は不利ですがキュー方式の調停回路を使っています。
優先順位をつけたい場合は、せいぜい２レベルにして、そのレベル間でのみ固定優先順位方式を使い、それぞれのレベルはキュー方式にしています。


### ライセンス

二条項BSDライセンス (2-clause BSD license) で公開しています。


